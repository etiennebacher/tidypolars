% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/collect.R
\name{compute.polars_lazy_frame}
\alias{compute.polars_lazy_frame}
\alias{collect.polars_lazy_frame}
\title{Run computations on a LazyFrame}
\usage{
\method{compute}{polars_lazy_frame}(
  x,
  ...,
  type_coercion = TRUE,
  predicate_pushdown = TRUE,
  projection_pushdown = TRUE,
  simplify_expression = TRUE,
  slice_pushdown = TRUE,
  comm_subplan_elim = TRUE,
  comm_subexpr_elim = TRUE,
  cluster_with_columns = TRUE,
  no_optimization = FALSE,
  engine = c("auto", "in-memory", "streaming"),
  streaming = FALSE
)

\method{collect}{polars_lazy_frame}(
  x,
  ...,
  type_coercion = TRUE,
  predicate_pushdown = TRUE,
  projection_pushdown = TRUE,
  simplify_expression = TRUE,
  slice_pushdown = TRUE,
  comm_subplan_elim = TRUE,
  comm_subexpr_elim = TRUE,
  cluster_with_columns = TRUE,
  no_optimization = FALSE,
  engine = c("auto", "in-memory", "streaming"),
  streaming = FALSE,
  .name_repair = "check_unique",
  uint8 = "integer",
  int64 = "double",
  date = "Date",
  time = "hms",
  decimal = "double",
  as_clock_class = FALSE,
  ambiguous = "raise",
  non_existent = "raise"
)
}
\arguments{
\item{x}{A Polars LazyFrame}

\item{...}{Dots which should be empty.}

\item{type_coercion}{Coerce types such that operations succeed and run on
minimal required memory (default is \code{TRUE}).}

\item{predicate_pushdown}{Applies filters as early as possible at scan level
(default is \code{TRUE}).}

\item{projection_pushdown}{Select only the columns that are needed at the scan
level (default is \code{TRUE}).}

\item{simplify_expression}{Various optimizations, such as constant folding
and replacing expensive operations with faster alternatives (default is
\code{TRUE}).}

\item{slice_pushdown}{Only load the required slice from the scan. Don't
materialize sliced outputs level. Don't materialize sliced outputs (default
is \code{TRUE}).}

\item{comm_subplan_elim}{Cache branching subplans that occur on self-joins or
unions (default is \code{TRUE}).}

\item{comm_subexpr_elim}{Cache common subexpressions (default is \code{TRUE}).}

\item{cluster_with_columns}{Combine sequential independent calls to
\verb{$with_columns()}.}

\item{no_optimization}{Sets the following optimizations to \code{FALSE}:
\code{predicate_pushdown}, \code{projection_pushdown},  \code{slice_pushdown},
\code{simplify_expression}. Default is \code{FALSE}.}

\item{engine}{The engine name to use for processing the query. One of the
followings:
\itemize{
\item \code{"auto"} (default): Select the engine automatically. The \code{"in-memory"}
engine will be selected for most cases.
\item \code{"in-memory"}: Use the in-memory engine.
\item \code{"streaming"}: Use the streaming engine, usually faster and can handle
larger-than-memory data.
}}

\item{streaming}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}} Deprecated, use \code{engine}
instead.}

\item{.name_repair, uint8, int64, date, time, decimal, as_clock_class, ambiguous, non_existent}{Parameters to control the conversion from polars types to R. See
\code{?polars:::as.data.frame.polars_lazy_frame} for explanations and accepted
values.}
}
\description{
\code{collect()} and \code{compute()} can be applied on a LazyFrame only. They both
check the validity of the query (for instance raising an error if a string operation
would be applied on a numeric column), optimize it in the background, and
perform computation.

These two functions differ in their output type:
\itemize{
\item \code{compute()} returns a \link[polars:pl__DataFrame]{Polars DataFrame};
\item \code{collect()} returns an R \link{data.frame}. Converting the output to an R \code{data.frame}
can be expensive, so \code{collect()} may consume more memory and take longer time.
}
}
\examples{
\dontshow{if (require("dplyr", quietly = TRUE) && require("tidyr", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
dat_lazy <- polars::as_polars_df(iris)$lazy()

compute(dat_lazy)

# you can build a query and add compute() as the last piece
dat_lazy |>
  select(starts_with("Sepal")) |>
  filter(between(Sepal.Length, 5, 6)) |>
  compute()

# call collect() instead to return a data.frame (note that this is more
# expensive than compute())
dat_lazy |>
  select(starts_with("Sepal")) |>
  filter(between(Sepal.Length, 5, 6)) |>
  collect()
\dontshow{\}) # examplesIf}
}
\seealso{
\code{\link[=fetch]{fetch()}} for applying a lazy query on a subset of the data.
}
