% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mutate.R
\name{mutate.RPolarsDataFrame}
\alias{mutate.RPolarsDataFrame}
\alias{mutate.RPolarsLazyFrame}
\title{Create, modify, and delete columns}
\usage{
\method{mutate}{RPolarsDataFrame}(.data, ..., .by = NULL, .keep = c("all", "used", "unused", "none"))

\method{mutate}{RPolarsLazyFrame}(.data, ..., .by = NULL, .keep = c("all", "used", "unused", "none"))
}
\arguments{
\item{.data}{A Polars Data/LazyFrame}

\item{...}{Name-value pairs. The name gives the name of the column in
the output. The value can be:
\itemize{
\item A vector the same length as the current group (or the whole data
frame if ungrouped).
\item NULL, to remove the column.
}

\code{across()} is mostly supported, except in a few cases. In particular, if the
\code{.cols} argument is \code{where(...)}, it will \emph{not} select variables that were
created before \code{across()}. Other select helpers are supported. See the examples.}

\item{.by}{Optionally, a selection of columns to group by for just this
operation, functioning as an alternative to \code{group_by()}. The group order
is not maintained, use \code{group_by()} if you want more control over it.}

\item{.keep}{Control which columns from \code{.data} are retained in the output.
Grouping columns and columns created by \code{...} are always kept.
\itemize{
\item \code{"all"} retains all columns from .data. This is the default.
\item \code{"used"} retains only the columns used in ... to create new columns. This is
useful for checking your work, as it displays inputs and outputs side-by-
side.
\item \code{"unused"} retains only the columns not used in \code{...} to create new columns.
This is useful if you generate new columns, but no longer need the columns
used to generate them.
\item \code{"none"} doesn't retain any extra columns from \code{.data}. Only the grouping
variables and columns created by \code{...} are kept.
}}
}
\description{
This creates new columns that are functions of existing variables. It
can also modify (if the name is the same as an existing column) and
delete columns (by setting their value to NULL).
}
\details{
A lot of functions available in base R (cos, mean, multiplying, etc.) or
in other packages (dplyr::lag(), etc.) are implemented in an efficient
way in Polars. These functions are automatically translated to Polars
syntax under the hood so that you can continue using the classic R syntax and
functions.

If a Polars built-in replacement doesn't exist (for example for custom
functions), then \code{tidypolars} will throw an error. See the vignette on Polars
expressions to know how to write custom functions that are accepted by
\code{tidypolars}.
}
\examples{
\dontshow{if (require("dplyr", quietly = TRUE) && require("tidyr", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
pl_iris <- polars0::as_polars_df(iris)

# classic operation
mutate(pl_iris, x = Sepal.Width + Sepal.Length)

# logical operation
mutate(pl_iris, x = Sepal.Width > Sepal.Length & Petal.Width > Petal.Length)

# overwrite existing variable
mutate(pl_iris, Sepal.Width = Sepal.Width * 2)

# grouped computation
pl_iris |>
  group_by(Species) |>
  mutate(foo = mean(Sepal.Length))

# an alternative syntax for grouping is to use `.by`
pl_iris |>
  mutate(foo = mean(Sepal.Length), .by = Species)

# across() is available
pl_iris |>
  mutate(
    across(.cols = contains("Sepal"), .fns = mean, .names = "{.fn}_of_{.col}")
  )
#
# It can receive several types of functions:
pl_iris |>
  mutate(
    across(
      .cols = contains("Sepal"),
      .fns = list(mean = mean, sd = ~ sd(.x)),
      .names = "{.fn}_of_{.col}"
    )
  )

# Be careful when using across(.cols = where(...), ...) as it will not include
# variables created in the same `...` (this is only the case for `where()`):
\dontrun{
pl_iris |>
  mutate(
    foo = 1,
    across(
      .cols = where(is.numeric),
      \(x) x - 1000 # <<<<<<<<< this will not be applied on variable "foo"
    )
  )
}
# Warning message:
# In `across()`, the argument `.cols = where(is.numeric)` will not take into account
# variables created in the same `mutate()`/`summarize` call.

# Embracing an external variable works
some_value <- 1
mutate(pl_iris, x = {{ some_value }})
\dontshow{\}) # examplesIf}
}
