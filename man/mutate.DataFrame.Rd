% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mutate.R
\name{mutate.DataFrame}
\alias{mutate.DataFrame}
\alias{mutate.LazyFrame}
\title{Create, modify, and delete columns}
\usage{
\method{mutate}{DataFrame}(.data, ..., .by = NULL)

\method{mutate}{LazyFrame}(.data, ..., .by = NULL)
}
\arguments{
\item{.data}{A Polars Data/LazyFrame}

\item{...}{Name-value pairs. The name gives the name of the column in
the output. The value can be:
\itemize{
\item A vector the same length as the current group (or the whole data
frame if ungrouped).
\item NULL, to remove the column.
}}

\item{.by}{Optionally, a selection of columns to group by for just this
operation, functioning as an alternative to \code{group_by()}.}
}
\description{
This creates new columns that are functions of existing variables. It
can also modify (if the name is the same as an existing column) and
delete columns (by setting their value to NULL).
}
\details{
A lot of functions available in base R (cos, sin, multiplying, etc.) or
in other packages (dplyr::lag(), etc.) are implemented in an efficient
way in Polars. These functions will be automatically translated to Polars
syntax under the hood so that you can continue using the classic R syntax and
functions.

If a Polars built-in replacement doesn't exist (for example for custom
functions), the R function will be passed to \code{map()} in the Polars workflow.
Note that this is slower than using functions that can be translated to
Polars syntax.
}
\examples{
\dontshow{if (require("dplyr", quietly = TRUE) && require("tidyr", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
pl_iris <- polars::pl$DataFrame(iris)

# classic operation
mutate(pl_iris, x = Sepal.Width + Sepal.Length)

# logical operation
mutate(pl_iris, x = Sepal.Width > Sepal.Length & Petal.Width > Petal.Length)

# overwrite existing variable
mutate(pl_iris, Sepal.Width = Sepal.Width*2)

# grouped computation
pl_iris |>
  group_by(Species) |>
  mutate(
    foo = mean(Sepal.Length)
  )

# across() is available
pl_iris |>
  mutate(
    across(.cols = contains("Sepal"), .fns = mean, .names = "{.fn}_of_{.col}")
  )
# It can receive several types of functions:
pl_iris |>
  mutate(
    across(
      .cols = contains("Sepal"),
      .fns = list(mean = mean, sd = ~ sd(.x)),
      .names = "{.fn}_of_{.col}"
    )
  )

# Embracing an external variable works
some_value <- 1
mutate(pl_iris, x = {{ some_value }})
\dontshow{\}) # examplesIf}
}
