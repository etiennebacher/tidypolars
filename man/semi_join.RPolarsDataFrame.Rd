% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join.R
\name{semi_join.RPolarsDataFrame}
\alias{semi_join.RPolarsDataFrame}
\alias{anti_join.RPolarsDataFrame}
\alias{semi_join.RPolarsLazyFrame}
\alias{anti_join.RPolarsLazyFrame}
\title{Filtering joins}
\usage{
\method{semi_join}{RPolarsDataFrame}(x, y, by = NULL, ..., na_matches = "na")

\method{anti_join}{RPolarsDataFrame}(x, y, by = NULL, ..., na_matches = "na")

\method{semi_join}{RPolarsLazyFrame}(x, y, by = NULL, ..., na_matches = "na")

\method{anti_join}{RPolarsLazyFrame}(x, y, by = NULL, ..., na_matches = "na")
}
\arguments{
\item{x, y}{Two Polars Data/LazyFrames}

\item{by}{Variables to join by. If \code{NULL} (default), \verb{*_join()} will
perform a natural join, using all variables in common across \code{x} and \code{y}. A
message lists the variables so that you can check they're correct; suppress
the message by supplying \code{by} explicitly.

\code{by} can take a character vector, like \code{c("x", "y")} if \code{x} and \code{y} are
in both datasets. To join on variables that don't have the same name, use
equalities in the character vector, like \code{c("x1" = "x2", "y")}. If you use
a character vector, the join can only be done using strict equality.

\code{by} can also be a specification created by \code{dplyr::join_by()}. Contrary
to the input as character vector shown above, \code{join_by()} uses unquoted
column names, e.g \code{join_by(x1 == x2, y)}.

Finally, \code{inner_join()} also supports inequality joins, e.g.
\code{join_by(x1 >= x2)}, and the helpers \code{between()}, \code{overlaps()}, and
\code{within()}. See the documentation of \code{\link[dplyr:join_by]{dplyr::join_by()}} for more
information. Other join types will likely support inequality joins in the
future.}

\item{...}{Dots which should be empty.}

\item{na_matches}{Should two \code{NA} values match?
\itemize{
\item \code{"na"}, the default, treats two \code{NA} values as equal.
\item \code{"never"} treats two \code{NA} values as different and will never match them
together or to any other values.
}

Note that when joining Polars Data/LazyFrames, \code{NaN} are always considered
equal, no matter the value of \code{na_matches}. This differs from the original
\code{dplyr} implementation.}
}
\description{
Filtering joins filter rows from \code{x} based on the presence or absence of
matches in \code{y}:
\itemize{
\item \code{semi_join()} return all rows from \code{x} with a match in \code{y}.
\item \code{anti_join()} return all rows from \code{x} without a match in \code{y}.
}
}
\section{Unknown arguments}{


Arguments that are supported by the original implementation in the tidyverse
but are not listed above will throw a warning by default if they are
specified. To change this behavior to error instead, use
\code{options(tidypolars_unknown_args = "error")}.
}

\examples{
\dontshow{if (require("dplyr", quietly = TRUE) && require("tidyr", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
test <- polars0::pl$DataFrame(
  x = c(1, 2, 3),
  y = c(1, 2, 3),
  z = c(1, 2, 3)
)

test2 <- polars0::pl$DataFrame(
  x = c(1, 2, 4),
  y = c(1, 2, 4),
  z2 = c(1, 2, 4)
)

test

test2

# only keep the rows of `test` that have matching keys in `test2`
semi_join(test, test2, by = c("x", "y"))

# only keep the rows of `test` that don't have matching keys in `test2`
anti_join(test, test2, by = c("x", "y"))
\dontshow{\}) # examplesIf}
}
