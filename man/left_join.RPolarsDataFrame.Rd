% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join.R
\name{left_join.RPolarsDataFrame}
\alias{left_join.RPolarsDataFrame}
\alias{right_join.RPolarsDataFrame}
\alias{full_join.RPolarsDataFrame}
\alias{inner_join.RPolarsDataFrame}
\alias{left_join.RPolarsLazyFrame}
\alias{right_join.RPolarsLazyFrame}
\alias{full_join.RPolarsLazyFrame}
\alias{inner_join.RPolarsLazyFrame}
\title{Mutating joins}
\usage{
\method{left_join}{RPolarsDataFrame}(
  x,
  y,
  by = NULL,
  copy = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = "na",
  relationship = NULL
)

\method{right_join}{RPolarsDataFrame}(
  x,
  y,
  by = NULL,
  copy = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = "na",
  relationship = NULL
)

\method{full_join}{RPolarsDataFrame}(
  x,
  y,
  by = NULL,
  copy = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = "na",
  relationship = NULL
)

\method{inner_join}{RPolarsDataFrame}(
  x,
  y,
  by = NULL,
  copy = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = "na",
  relationship = NULL
)

\method{left_join}{RPolarsLazyFrame}(
  x,
  y,
  by = NULL,
  copy = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = "na",
  relationship = NULL
)

\method{right_join}{RPolarsLazyFrame}(
  x,
  y,
  by = NULL,
  copy = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = "na",
  relationship = NULL
)

\method{full_join}{RPolarsLazyFrame}(
  x,
  y,
  by = NULL,
  copy = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = "na",
  relationship = NULL
)

\method{inner_join}{RPolarsLazyFrame}(
  x,
  y,
  by = NULL,
  copy = NULL,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL,
  na_matches = "na",
  relationship = NULL
)
}
\arguments{
\item{x, y}{Two Polars Data/LazyFrames}

\item{by}{Variables to join by. If \code{NULL} (default), \verb{*_join()} will
perform a natural join, using all variables in common across \code{x} and \code{y}. A
message lists the variables so that you can check they're correct; suppress
the message by supplying \code{by} explicitly.

\code{by} can take a character vector, like \code{c("x", "y")} if \code{x} and \code{y} are
in both datasets. To join on variables that don't have the same name, use
equalities in the character vector, like \code{c("x1" = "x2", "y")}. If you use
a character vector, the join can only be done using strict equality.

\code{by} can also be a specification created by \code{dplyr::join_by()}. Contrary
to the input as character vector shown above, \code{join_by()} uses unquoted
column names, e.g \code{join_by(x1 == x2, y)}.

Finally, \code{inner_join()} also supports inequality joins, e.g.
\code{join_by(x1 >= x2)}, and the helpers \code{between()}, \code{overlaps()}, and
\code{within()}. See the documentation of \code{\link[dplyr:join_by]{dplyr::join_by()}} for more
information. Other join types will likely support inequality joins in the
future.}

\item{copy, keep}{Not used.}

\item{suffix}{If there are non-joined duplicate variables in \code{x} and \code{y},
these suffixes will be added to the output to disambiguate them. Should be a
character vector of length 2.}

\item{...}{Not used.}

\item{na_matches}{Should two \code{NA} values match?
\itemize{
\item \code{"na"}, the default, treats two \code{NA} values as equal.
\item \code{"never"} treats two \code{NA} values as different and will never match them
together or to any other values.
}

Note that when joining Polars Data/LazyFrames, \code{NaN} are always considered
equal, no matter the value of \code{na_matches}. This differs from the original
\code{dplyr} implementation.}

\item{relationship}{Handling of the expected relationship between the keys of
\code{x} and \code{y}. Must be one of the following:
\itemize{
\item \code{NULL}, the default, is equivalent to \code{"many-to-many"}. It doesn't expect
any relationship between \code{x} and \code{y}.
\item \code{"one-to-one"} expects each row in \code{x} to match at most 1 row in \code{y} and
each row in \code{y} to match at most 1 row in \code{x}.
\item \code{"one-to-many"} expects each row in \code{y} to match at most 1 row in \code{x}.
\item \code{"many-to-one"} expects each row in \code{x} matches at most 1 row in \code{y}.
}}
}
\description{
Mutating joins add columns from \code{y} to \code{x}, matching observations based on
the keys.
}
\examples{
\dontshow{if (require("dplyr", quietly = TRUE) && require("tidyr", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
test <- polars::pl$DataFrame(
  x = c(1, 2, 3),
  y1 = c(1, 2, 3),
  z = c(1, 2, 3)
)

test2 <- polars::pl$DataFrame(
  x = c(1, 2, 4),
  y2 = c(1, 2, 4),
  z2 = c(4, 5, 7)
)

test

test2

# default is to use common columns, here "x" only
left_join(test, test2)

# we can specify the columns on which to join with join_by()...
left_join(test, test2, by = join_by(x, y1 == y2))

# ... or with a character vector
left_join(test, test2, by = c("x", "y1" = "y2"))

# we can customize the suffix of common column names not used to join
test2 <- polars::pl$DataFrame(
  x = c(1, 2, 4),
  y1 = c(1, 2, 4),
  z = c(4, 5, 7)
)

left_join(test, test2, by = "x", suffix = c("_left", "_right"))

# the argument "relationship" ensures the join matches the expectation
country <- polars::pl$DataFrame(
  iso = c("FRA", "DEU"),
  value = 1:2
)
country

country_year <- polars::pl$DataFrame(
  iso = rep(c("FRA", "DEU"), each = 2),
  year = rep(2019:2020, 2),
  value2 = 3:6
)
country_year

# We expect that each row in "x" matches only one row in "y" but, it's not
# true as each row of "x" matches two rows of "y"
tryCatch(
  left_join(country, country_year, join_by(iso), relationship = "one-to-one"),
  error = function(e) e
)

# A correct expectation would be "one-to-many":
left_join(country, country_year, join_by(iso), relationship = "one-to-many")
\dontshow{\}) # examplesIf}
}
