% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fetch.R
\name{fetch}
\alias{fetch}
\title{Fetch \code{n} rows of a LazyFrame}
\usage{
fetch(
  .data,
  n_rows = 500,
  type_coercion = TRUE,
  predicate_pushdown = TRUE,
  projection_pushdown = TRUE,
  simplify_expression = TRUE,
  slice_pushdown = TRUE,
  comm_subplan_elim = TRUE,
  comm_subexpr_elim = TRUE,
  no_optimization = FALSE,
  streaming = FALSE
)
}
\arguments{
\item{.data}{A Polars LazyFrame}

\item{n_rows}{Number of rows to fetch.}

\item{type_coercion}{Coerce types such that operations succeed and run on
minimal required memory (default is \code{TRUE}).}

\item{predicate_pushdown}{Applies filters as early as possible at scan level
(default is \code{TRUE}).}

\item{projection_pushdown}{Select only the columns that are needed at the scan
level (default is \code{TRUE}).}

\item{simplify_expression}{Various optimizations, such as constant folding
and replacing expensive operations with faster alternatives (default is
\code{TRUE}).}

\item{slice_pushdown}{Only load the required slice from the scan. Don't
materialize sliced outputs level. Don't materialize sliced outputs (default
is \code{TRUE}).}

\item{comm_subplan_elim}{Cache branching subplans that occur on self-joins or
unions (default is \code{TRUE}).}

\item{comm_subexpr_elim}{Cache common subexpressions (default is \code{TRUE}).}

\item{no_optimization}{Sets the following optimizations to \code{FALSE}:
\code{predicate_pushdown}, \code{projection_pushdown},  \code{slice_pushdown},
\code{simplify_expression}. Default is \code{FALSE}.}

\item{streaming}{Run parts of the query in a streaming fashion (this is in
an alpha state). Default is \code{FALSE}.}
}
\description{
Fetch is a way to collect only the first \code{n} rows of a LazyFrame. It is
mainly used to test that a query runs as expected on a subset of the data
before using \code{pl_collect()} on the full query. Note that fetching \code{n} rows
doesn't mean that the output will actually contain \code{n} rows, see the section
'Details' for more information.
}
\details{
The parameter \code{n_rows} indicates how many rows from the LazyFrame should be
used at the beginning of the query, but it doesn't guarantee that \code{n_rows} will
be returned. For example, if the query contains a filter or join operations
with other datasets, then the final number of rows can be lower than \code{n_rows}.
On the other hand, appending some rows during the query can lead to an output
that has more rows than \code{n_rows}.
}
\examples{
dat_lazy <- polars::pl$DataFrame(iris)$lazy()

# this will return 30 rows
fetch(dat_lazy, 30)

# this will return less than 30 rows because there are less than 30 matches
# for this filter in the whole dataset
dat_lazy |>
  pl_filter(Sepal.Length > 7.0) |>
  fetch(30)
}
\seealso{
\code{\link[=pl_collect]{pl_collect()}} for applying a lazy query on the full data.
}
