% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sink.R
\name{sink_ndjson}
\alias{sink_ndjson}
\title{Stream output to a NDJSON file}
\usage{
sink_ndjson(
  .data,
  path,
  ...,
  maintain_order = TRUE,
  type_coercion = TRUE,
  predicate_pushdown = TRUE,
  projection_pushdown = TRUE,
  simplify_expression = TRUE,
  slice_pushdown = TRUE,
  no_optimization = FALSE,
  mkdir = FALSE
)
}
\arguments{
\item{.data}{A Polars LazyFrame.}

\item{path}{Output file. Can also be a \verb{partition_*()} function to export the
output to multiple files (see Details section below).}

\item{...}{Ignored.}

\item{maintain_order}{Whether maintain the order the data was processed
(default is \code{TRUE}). Setting this to \code{FALSE} will be slightly faster.}

\item{type_coercion}{Coerce types such that operations succeed and run on
minimal required memory (default is \code{TRUE}).}

\item{predicate_pushdown}{Applies filters as early as possible at scan level
(default is \code{TRUE}).}

\item{projection_pushdown}{Select only the columns that are needed at the
scan level (default is \code{TRUE}).}

\item{simplify_expression}{Various optimizations, such as constant folding
and replacing expensive operations with faster alternatives (default is
\code{TRUE}).}

\item{slice_pushdown}{Only load the required slice from the scan. Don't
materialize sliced outputs level. Don't materialize sliced outputs (default
is \code{TRUE}).}

\item{no_optimization}{Sets the following optimizations to \code{FALSE}:
\code{predicate_pushdown}, \code{projection_pushdown},  \code{slice_pushdown},
\code{simplify_expression}. Default is \code{FALSE}.}

\item{mkdir}{Recursively create all the directories in the path.}
}
\value{
The input LazyFrame.
}
\description{
This writes the output of a query directly to a NDJSON file without collecting
it in the R session first. This is useful if the output of the query is still
larger than RAM as it would crash the R session if it was collected into R.
}
\details{
\subsection{Partitioned output}{

It is possible to export data to multiple files based on various parameters,
such as the values of some variables, or such that each file has a maximum
number of rows. See \code{\link[=partition_by]{partition_by()}} for more details.
}
}
\examples{
\dontshow{if (require("dplyr", quietly = TRUE) && require("tidyr", quietly = TRUE) && require("jsonlite", quietly = TRUE)) withAutoprint(\{ # examplesIf}
# This is an example workflow where sink_ndjson() is not very useful because
# the data would fit in memory. It simply is an example of using it at the
# end of a piped workflow.

# Create files for the NDJSON input and output:
file_ndjson <- tempfile(fileext = ".ndjson")
file_ndjson2 <- tempfile(fileext = ".ndjson")

# Write some data in a CSV file
fake_data <- do.call("rbind", rep(list(mtcars), 1000))
jsonlite::stream_out(fake_data, file(file_ndjson), verbose = FALSE)

# In a new R session, we could read this file as a LazyFrame, do some operations,
# and write it to another NDJSON file without ever collecting it in the R session:
scan_ndjson_polars(file_ndjson) |>
  filter(cyl \%in\% c(4, 6), mpg > 22) |>
  mutate(
    hp_gear_ratio = hp / gear
  ) |>
  sink_ndjson(path = file_ndjson2)


#----------------------------------------------
# Write a LazyFrame to multiple files depending on various strategies.
my_lf <- as_polars_lf(mtcars)

# Split the LazyFrame by key(s) and write each split to a different file:
out_path <- withr::local_tempdir()
sink_ndjson(my_lf, partition_by_key(out_path, by = c("am", "cyl")), mkdir = TRUE)
fs::dir_tree(out_path)

# Split the LazyFrame by max number of rows per file:
out_path <- withr::local_tempdir()
sink_ndjson(my_lf, partition_by_max_size(out_path, max_size = 5), mkdir = TRUE)
fs::dir_tree(out_path) # mtcars has 32 rows so we have 7 output files
\dontshow{\}) # examplesIf}
}
