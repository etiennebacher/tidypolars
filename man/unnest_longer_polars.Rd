% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unnest.R
\name{unnest_longer_polars}
\alias{unnest_longer_polars}
\title{Unnest a list-column into rows}
\usage{
unnest_longer_polars(
  data,
  col,
  ...,
  values_to = NULL,
  indices_to = NULL,
  keep_empty = FALSE
)
}
\arguments{
\item{data}{A Polars DataFrame or LazyFrame.}

\item{col}{<\code{\link[tidyr:tidyr_tidy_select]{tidy-select}}> Column(s) to unnest. Can be
bare column names, character strings, or tidyselect expressions. When
selecting multiple columns, the list elements in each row must have the
same length across all selected columns.}

\item{...}{These dots are for future extensions and must be empty.}

\item{values_to}{A string giving the column name to store the unnested values
in. If \code{NULL} (the default), the original column name is used. When
multiple columns are selected, this can be a glue string containing
\code{"{col}"} to provide a template for the column names (e.g.,
\code{values_to = "{col}_val"}).}

\item{indices_to}{A string giving the column name to store the index of the
values. If \code{NULL} (the default), no index column is created. When multiple
columns are selected, this can be a glue string containing \code{"{col}"} to
create separate index columns for each unnested column (e.g.,
\code{indices_to = "{col}_idx"}).}

\item{keep_empty}{If \code{TRUE}, empty values (NULL or empty lists) are kept as
\code{NA} in the output. If \code{FALSE} (the default), empty values are dropped.}
}
\value{
A Polars DataFrame or LazyFrame with the list-column(s) unnested into
rows.
}
\description{
\code{unnest_longer_polars()} turns each element of a list-column into a row.
This is a polars-specific implementation based on \code{polars$explode()}.
}
\details{
When multiple columns are selected, the corresponding list elements from each
row are expanded together. This requires that all selected columns have lists
of the same length in each row.

The \code{indices_to} parameter creates an integer column with the position
(1-indexed) of each element within the original list. Named elements in the
list are not currently supported for index names (they will use integer
positions).

When using \code{"{col}"} templates with multiple columns, the template is applied
to each column name to generate the output column names.
}
\examples{
\dontshow{if (require("dplyr", quietly = TRUE) && require("tidyr", quietly = TRUE)) withAutoprint(\{ # examplesIf}
library(polars)

# Basic example with a list column
df <- pl$DataFrame(
  id = 1:3,
  values = list(c(1, 2), c(3, 4, 5), 6)
)
df

unnest_longer_polars(df, values)

# With indices
unnest_longer_polars(df, values, indices_to = "idx")

# Rename the output column
unnest_longer_polars(df, values, values_to = "val")

# Multiple columns - list elements must have same length per row
df2 <- pl$DataFrame(
  id = 1:2,
  a = list(c(1, 2), c(3, 4)),
  b = list(c("x", "y"), c("z", "w"))
)
unnest_longer_polars(df2, c(a, b))

# Multiple columns with values_to template
unnest_longer_polars(df2, c(a, b), values_to = "{col}_val")

# Multiple columns with indices_to template
unnest_longer_polars(df2, c(a, b), indices_to = "{col}_idx")

# Example with strings split into a list
df3 <- pl$DataFrame(
  id = 1:2,
  tags = list(c("apple", "banana"), c("grape", "pear"))
)

unnest_longer_polars(df3, tags)

# keep_empty example
df4 <- pl$DataFrame(
  id = 1:3,
  values = list(c(1, 2), NULL, 3)
)

# By default, NULL/empty values are dropped
unnest_longer_polars(df4, values)

# Use keep_empty = TRUE to keep them as NA
unnest_longer_polars(df4, values, keep_empty = TRUE)
\dontshow{\}) # examplesIf}
}
\seealso{
\code{\link[tidyr:unnest_longer]{tidyr::unnest_longer()}} for the tidyr equivalent.
}
