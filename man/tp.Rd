% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tp.R
\docType{data}
\name{tp}
\alias{tp}
\title{Get tidypolars function translation without loading their original package}
\usage{
tp
}
\description{
Use \code{tp$function_name()} to get access to the functions that are translated
by \code{tidypolars} without loading the package these functions originally come
from.

This may be useful in cases where you want to benefit from the interface of
these functions but don't want to add some \code{tidyverse} dependencies to your
project (e.g. \code{stringr} because it might be slow to build the package in some
cases).

Note that the name of the package that originally provided the function must
be appended to the function name. For instance, if you want to use
\code{stringr::str_extract()} without loading \code{stringr}, you can do so with
\code{tp$str_extract_stringr()}. This is because multiple packages may have a
function named \code{str_extract()}, so we need to inform \code{tidypolars} of which
translation we want exactly.

\strong{Note:} using \code{tp} will make it harder to convert \code{tidypolars} code to run
with other \code{tidyverse}-based backends because \code{tp} will be unknown to those
backends. If you expect to switch between \code{tidypolars}, the original \code{tidyverse},
and \code{tidyverse}-based backends, you should avoid using \code{tp}and load the original
packages in the session instead.

This is similar to the \code{dd} object in \code{duckplyr} and to the \code{.sql} object in
\code{dbplyr}.
}
\examples{
\dontshow{if (require("dplyr", quietly = TRUE)) withAutoprint(\{ # examplesIf}
# List of all functions stored in this object
sort(names(tp))

dat <- pl$DataFrame(x = c("abc12", "def3"))
dat |>
  mutate(y = tp$str_extract_stringr(x, "\\\\d+"))
\dontshow{\}) # examplesIf}
}
\keyword{datasets}
