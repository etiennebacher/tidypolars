% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter.R
\name{filter.polars_data_frame}
\alias{filter.polars_data_frame}
\alias{filter.polars_lazy_frame}
\alias{filter_out.polars_data_frame}
\alias{filter_out.polars_lazy_frame}
\title{Keep or drop rows that match a condition}
\usage{
\method{filter}{polars_data_frame}(.data, ..., .by = NULL)

\method{filter}{polars_lazy_frame}(.data, ..., .by = NULL)

\method{filter_out}{polars_data_frame}(.data, ..., .by = NULL)

\method{filter_out}{polars_lazy_frame}(.data, ..., .by = NULL)
}
\arguments{
\item{.data}{A Polars Data/LazyFrame}

\item{...}{Expressions that return a logical value, and are defined in terms
of the variables in the data. If multiple expressions are included, they
will be combined with the & operator. Only rows for which all conditions
evaluate to \code{TRUE} are kept (for \code{filter()}) or dropped (for \code{filter_out()}).}

\item{.by}{Optionally, a selection of columns to group by for just this
operation, functioning as an alternative to \code{group_by()}. The group order
is not maintained, use \code{group_by()} if you want more control over it.}
}
\description{
These functions are used to subset a data frame, applying the expressions in \code{...} to
determine which rows should be kept (for \code{filter()}) or dropped (for \code{filter_out()}).

Multiple conditions can be supplied separated by a comma. These will be combined with
the \code{&} operator.

Both \code{filter()} and \code{filter_out()} treat \code{NA} like \code{FALSE}. This subtle behavior can impact
how you write your conditions when missing values are involved. See the section on \verb{Missing values} for important details and examples.

\code{filter_out()} is available for \code{dplyr} >= 1.2.0.
}
\section{Missing values}{


Read this section in the \href{https://dplyr.tidyverse.org/dev/reference/filter.html#missing-values}{\code{dplyr} documentation}.
}

\examples{
\dontshow{if (require("dplyr", quietly = TRUE) && require("tidyr", quietly = TRUE)) withAutoprint(\{ # examplesIf}
starwars <- as_polars_df(dplyr::starwars)

# Filtering for one criterion
filter(starwars, species == "Human")

# Filtering for multiple criteria within a single logical expression
filter(starwars, hair_color == "none" & eye_color == "black")
filter(starwars, hair_color == "none" | eye_color == "black")

# When multiple expressions are used, they are combined using &
filter(starwars, hair_color == "none", eye_color == "black")

# Filtering out to drop rows
filter_out(starwars, hair_color == "none")

# When filtering out, it can be useful to first interactively filter for the
# rows you want to drop, just to double check that you've written the
# conditions correctly. Then, just change `filter()` to `filter_out()`.
filter(starwars, mass > 1000, eye_color == "orange")
filter_out(starwars, mass > 1000, eye_color == "orange")

# The filtering operation may yield different results on grouped
# tibbles because the expressions are computed within groups.
#
# The following keeps rows where `mass` is greater than the
# global average:
starwars |> filter(mass > mean(mass, na.rm = TRUE))

# Whereas this keeps rows with `mass` greater than the per `gender`
# average:
starwars |> filter(mass > mean(mass, na.rm = TRUE), .by = gender)

# If you find yourself trying to use a `filter()` to drop rows, then
# you should consider if switching to `filter_out()` can simplify your
# conditions. For example, to drop blond individuals, you might try:
starwars |> filter(hair_color != "blond")

# But this also drops rows with an `NA` hair color! To retain those:
starwars |> filter(hair_color != "blond" | is.na(hair_color))

# But explicit `NA` handling like this can quickly get unwieldy, especially
# with multiple conditions. Since your intent was to specify rows to drop
# rather than rows to keep, use `filter_out()`. This also removes the need
# for any explicit `NA` handling.
starwars |> filter_out(hair_color == "blond")
\dontshow{\}) # examplesIf}
}
