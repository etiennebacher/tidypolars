#' Pivot a DataFrame from long to wide
#'
#' @param data A Polars DataFrame (LazyFrames are not supported).
#' @inheritParams rlang::check_dots_empty0
#' @param id_cols A set of columns that uniquely identify each observation.
#'   Typically used when you have redundant variables, i.e. variables whose
#'   values are perfectly correlated with existing variables.
#'
#'   Defaults to all columns in data except for the columns specified through
#'   `names_from` and `values_from`. If a tidyselect expression is supplied, it
#'   will be evaluated on data after removing the columns specified through
#'   `names_from` and `values_from`.
#'
#' @param names_from The (quoted or unquoted) column names whose values will be
#'   used for the names of the new columns.
#' @param values_from The (quoted or unquoted) column names whose values will be
#'   used to fill the new columns.
#' @param names_prefix String added to the start of every variable name. This is
#'   particularly useful if `names_from` is a numeric vector and you want to
#'   create syntactic variable names.
#' @param names_sep If `names_from` or `values_from` contains multiple
#'   variables, this will be used to join their values together into a single
#'   string to use as a column name.
#' @param names_glue Instead of `names_sep` and `names_prefix`, you can supply a
#'   `glue` specification that uses the `names_from` columns to create custom
#'   column names.
#' @param values_fill A scalar that will be used to replace missing values in
#'   the new columns. Note that the type of this value will be applied to new
#'   columns. For example, if you provide a character value to fill numeric
#'   columns, then all these columns will be converted to character.
#'
#' @inheritSection left_join.polars_data_frame Unknown arguments
#'
#' @export
#' @examplesIf require("dplyr", quietly = TRUE) && require("tidyr", quietly = TRUE)
#' pl_fish_encounters <- as_polars_df(tidyr::fish_encounters)
#'
#' pl_fish_encounters |>
#'   pivot_wider(names_from = station, values_from = seen)
#'
#' pl_fish_encounters |>
#'   pivot_wider(names_from = station, values_from = seen, values_fill = 0)
#'
#' # be careful about the type of the replacement value!
#' pl_fish_encounters |>
#'   pivot_wider(names_from = station, values_from = seen, values_fill = "a")
#'
#' # using "names_glue" to specify the names of new columns
#' production <- expand.grid(
#'   product = c("A", "B"),
#'   country = c("AI", "EI"),
#'   year = 2000:2014
#' ) |>
#'   filter((product == "A" & country == "AI") | product == "B") |>
#'   mutate(production = 1:45) |>
#'   as_polars_df()
#'
#' production
#'
#' production |>
#'   pivot_wider(
#'     names_from = c(product, country),
#'     values_from = production,
#'     names_glue = "prod_{product}_{country}"
#'   )
pivot_wider.polars_data_frame <- function(
  data,
  ...,
  id_cols = NULL,
  names_from = name,
  values_from = value,
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  values_fill = NULL
) {
  check_dots_empty_ignore(
    ...,
    .unsupported = c(
      "id_expand",
      "names_sort",
      "names_vary",
      "names_expand",
      "names_repair",
      "values_fn",
      "unused_fn"
    )
  )
  check_string(names_prefix, allow_null = TRUE)

  data_names <- names(data)
  value_vars <- tidyselect_named_arg(data, rlang::enquo(values_from))
  names_vars <- tidyselect_named_arg(data, rlang::enquo(names_from))
  id_cols <- setdiff(
    tidyselect_named_arg(data, rlang::enquo(id_cols)),
    c(value_vars, names_vars)
  )
  id_vars <- id_cols %||% data_names[!data_names %in% c(value_vars, names_vars)]

  if (length(value_vars) == 0) {
    cli_abort("Must select at least one variable in {.code values_from}.")
  }

  if (length(names_vars) == 0) {
    cli_abort("Must select at least one variable in {.code names_from}.")
  }

  on_columns <- data$select(!!!names_vars)$unique(maintain_order = TRUE) |>
    as.data.frame()

  new_data <- data$pivot(
    values = value_vars,
    on = names_vars,
    on_columns = on_columns,
    index = id_vars,
    separator = names_sep
  )

  # names of columns generated by polars
  new_cols <- setdiff(names(new_data), names(data))
  new_cols_df <- new_cols |>
    strsplit("\\\",\\\"") |>
    lapply(\(x) {
      x |>
        gsub("^\\{\\\"", "", x = _) |>
        gsub("\\\"\\}$", "", x = _) |>
        cbind() |>
        t() |>
        as.data.frame() |>
        setNames(names_vars)
    }) |>
    bind_rows()

  if (!is.null(names_glue)) {
    final_cols <- glue::glue_data(new_cols_df, names_glue)
    names_prefix <- NULL
  } else if (length(value_vars) > 1 && length(names_vars) == 1) {
    final_cols <- setdiff(names(new_data), data_names)
  } else {
    final_cols <- do.call(paste, c(new_cols_df, sep = names_sep))
  }

  names(new_cols) <- final_cols

  if (!is.null(names_prefix)) {
    names(new_cols) <- paste0(names_prefix, final_cols)
  }

  mapping <- as.list(names(new_cols))
  names(mapping) <- unlist(new_cols)
  new_data <- new_data$rename(!!!mapping)

  out <- if (!is.null(values_fill)) {
    new_data$with_columns(
      pl$col(!!!new_cols)$fill_null(values_fill)
    )
  } else {
    new_data
  }
  add_tidypolars_class(out)
}

#' @rdname pivot_wider.polars_data_frame
#' @export
pivot_wider.polars_lazy_frame <- pivot_wider.polars_data_frame
