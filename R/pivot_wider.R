#' Pivot Data/LazyFrame from long to wide
#'
#' @param names_from The (quoted or unquoted) column name whose values will be
#'   used for the names of the new columns.
#' @param values_from The (quoted or unquoted) column name whose values will be
#'   used to fill the new columns.
#' @param names_prefix String added to the start of every variable name. This is
#'   particularly useful if `names_from` is a numeric vector and you want to
#'   create syntactic variable names.
#' @param names_sep If `names_from` or `values_from` contains multiple
#'   variables, this will be used to join their values together into a single
#'   string to use as a column name.
#' @param names_glue Instead of `names_sep` and `names_prefix`, you can supply a
#'   `glue` specification that uses the `names_from` columns to create custom
#'   column names.
#' @param values_fill A scalar that will be used to replace missing values in
#'   the new columns. Note that the type of this value will be applied to new
#'   columns. For example, if you provide a character value to fill numeric
#'   columns, then all these columns will be converted to character.
#' @inheritParams slice_tail.RPolarsDataFrame
#'
#' @export
#' @examplesIf require("dplyr", quietly = TRUE) && require("tidyr", quietly = TRUE)
#' pl_fish_encounters <- polars::pl$DataFrame(tidyr::fish_encounters)
#'
#' pl_fish_encounters |>
#'   pivot_wider(names_from = station, values_from = seen)
#'
#' pl_fish_encounters |>
#'   pivot_wider(names_from = station, values_from = seen, values_fill = 0)
#'
#' # be careful about the type of the replacement value!
#' pl_fish_encounters |>
#'   pivot_wider(names_from = station, values_from = seen, values_fill = "a")

pivot_wider.RPolarsDataFrame <- function(data, ..., names_from, values_from,
                                  names_prefix = "", names_sep = "_", names_glue = NULL,
                                  values_fill = NULL) {

  check_polars_data(data)

  data_names <- pl_colnames(data)
  value_vars <- tidyselect_named_arg(data, rlang::enquo(values_from))
  names_vars <- tidyselect_named_arg(data, rlang::enquo(names_from))
  id_vars <- data_names[!data_names %in% c(value_vars, names_vars)]

  new_data <- data$pivot(
    values = value_vars,
    columns = names_vars,
    index = id_vars,
    separator = names_sep
  )

  # names of columns generated by polars
  new_cols <- setdiff(names(new_data), names(data)) |>
    as.list()

  # names that should be put on new columns at the end
  final_cols <- select(data, all_of(names_vars)) |>
    distinct() |>
    as.data.frame()

  # browser()

  if (!is.null(names_glue)) {
    final_cols <- glue::glue_data(final_cols, names_glue)
    names_prefix <- NULL
  } else {
    final_cols <- do.call(paste, c(final_cols, sep = names_sep))
  }

  names(new_cols) <- final_cols

  if (!is.null(names_prefix)) {
    if (length(names_prefix) > 1) {
      rlang::abort("`names_prefix` must be of length 1.")
    }
    names(new_cols) <- paste0(names_prefix, final_cols)
  }

  new_data <- new_data$rename(new_cols)

  if (length(value_vars) > 1) {
    tmp <- paste(value_vars, collapse = "|")
    old_names <- grep(
      paste0("^(", tmp, ")", names_sep, names_vars),
      names(new_data),
      value = TRUE
    )
    new_names <- gsub(
      paste0("^(", tmp, ")", names_sep, "(", names_vars, ")"),
      "\\1",
      old_names
    )
    replacements <- as.list(old_names)
    names(replacements) <- new_names
    new_data <- new_data$rename(replacements)
  }

  out <- if (!is.null(values_fill)) {
    new_data$with_columns(
      pl$col(new_cols)$fill_null(values_fill)
    )
  } else {
    new_data
  }

  add_tidypolars_class(out)
}

#' @rdname pivot_wider.RPolarsDataFrame
#' @export
pivot_wider.RPolarsLazyFrame <- pivot_wider.RPolarsDataFrame
